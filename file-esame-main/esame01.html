
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>HTML 5 Boilerplate</title>
    <style>
      body {
        font-family: sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 1em;
      }
      li {
      }
      code {
        background-color: seashell;
      }
    </style>
  </head>
  <body>
  <h1>Esame 01</h1>
<h2>Descrizione del Problema</h2>
<p>Vogliamo implementare un programma che gestisce un insieme di record. Ogni
record è composto da un nome, un identificatore e da un valore intero. Non
possono esistere due record con lo stesso identificatore; ma possono esistere
due record con lo stesso nome o con lo stesso valore. Il programma deve
permettere di cancellare un record esistente, di modificare il valore e il nome
di un record esistente, di caricare i records da un file di testo e di salvare i
records su un file di testo. Si può assumere che i nomi dei record siano
stringhe di lunghezza massima 127.</p>
<p>Il formato dei files di testo è il seguente: ogni riga contiene un record e
consiste di tre parti separate da spazi. La prima parte è l'identificatore del
record, la seconda parte è il nome e la terza il valore intero. Per esempio, la
riga <code>2716621 Pippo 5</code> contiene il record con indetificatore <code>2716621</code>, il nome
<code>Pippo</code> e il valore <code>5</code>. Il file è composto da sole righe che contengono
records, e non riporta a priori il numero dei records contenuti nel file.</p>
<p>La funziona di ricerca restituisce la posizione del record nell'array di
records. Esiste una funzione di ricerca sia per cercare per identitificatore che
per nome. Se il record non esiste, la funzione ritorna <code>-1</code>. Nel caso della
ricerca per nome, la funzione ritorna la posizione del primo record con quel
nome, e prende un valore aggiuntivo che indica la posizione da cui iniziare la
ricerca.</p>
<p>La cancellazione viene fatta modificando un record esistente e assegnando
all'identificatore il valore <code>-1</code>, al nome la stringa vuota, e al valore il
numero <code>0</code>. Nella cancellazione non si devono spostare i record rimanenti. Il
programma supporta anche la cancellazione di tutti i record con lo stesso nome.</p>
<p>L'inserimento di un nuovo record viene fatto nella prima posizione vuota, cioè
con identificatore <code>-1</code>. Se non esiste una posizione vuota, si aggiunge un
record alla fine dell'array.</p>
<p>Il programma permette anche di calcolare la somma dei valori dei record con lo
stesso nome, e di contare i record validi.</p>
<p>Il problema va risolto implementando una serie di funzioni che operano su una
struttura dati che rappresenta l'insieme dei records. La struttura dati deve
essere implementata come un array dinamico. È consigliato usare un array
dinamico che permette l'inserimento in coda in modo efficiente.</p>
<p>Suggerimento 1: È consigliato inizializzare il set di records con una dimensione
iniziale di 4.</p>
<p>Suggerimento 2: Per la lettura di file è permesso leggere record fino a che non
si incontra un errore di lettura, che si può testare con <code>if(fs)</code> o <code>while(fs)</code>
dove <code>fs</code> è lo stream.</p>
<p>Suggerimento 3: Potete usare la funzione <code>print()</code>, già implementata, per
stampare i record correnti.</p>
<h2>Funzioni e Punteggio</h2>
<ul>
<li><code>RecordSet init()</code>: 2 punti<ul>
<li>crea un array vuoto di records</li>
</ul>
</li>
<li><code>void drop(RecordSet&amp; rs)</code>: 1 punti<ul>
<li>dealloca l'array di records</li>
</ul>
</li>
<li><code>int insert(RecordSet&amp; rs, int id, const char* name, int value)</code>: 6 punti<ul>
<li>inserisce un nuovo record nella prima posizione libera o alla fine
dell'array; inserisce il record solo se un record con lo stesso
identificatore non esiste</li>
<li>ritorna la posizione del record inserito o <code>-1</code> se il record esiste già</li>
</ul>
</li>
<li><code>int rcount(const RecordSet&amp; rs)</code>: 1 punti<ul>
<li>ritorna il numero dei record validi, cioè con identificatore diverso da <code>-1</code></li>
</ul>
</li>
<li><code>int vsum(const RecordSet&amp; rs, const char* name)</code>: 2 punti<ul>
<li>ritorna la somma dei valori dei record con nome dato</li>
</ul>
</li>
<li><code>int search(const RecordSet&amp; rs, int id)</code>: 2 punti<ul>
<li>restituisce l'indice del record con identificatore dato o <code>-1</code> se il record
non esiste</li>
</ul>
</li>
<li><code>int find(const RecordSet&amp; rs, const char* name, int start)</code>: 3 punti<ul>
<li>restituisce l'indice del record con nome dato o <code>-1</code> se il record non
esiste, iniziando la ricerca dalla posizione <code>start</code></li>
</ul>
</li>
<li><code>int update(RecordSet&amp; rs, int id, int value)</code>: 2 punti<ul>
<li>modifica il valore del record con identificatore dato</li>
<li>ritora la posizione del record cambiato o <code>-1</code> se il record non esiste</li>
</ul>
</li>
<li><code>int remove(RecordSet&amp; rs, int id)</code>: 2 punti<ul>
<li>rimuove il record con nome dato</li>
<li>ritora la posizione del record eliminato o <code>-1</code> se il record non esiste</li>
</ul>
</li>
<li><code>int erase(RecordSet&amp; rs, const char* name)</code>: 3 punti<ul>
<li>rimuove tutti i record con nome dato</li>
<li>ritora la posizione del primo record eliminato o <code>-1</code> se nessun record ha il
nome dato</li>
</ul>
</li>
<li><code>RecordSet load(const char* filename)</code>: 5 punti<ul>
<li>carica i records dal file di testo</li>
<li>ritorna l'array di records caricati o l'array vuoto in caso di errore</li>
</ul>
</li>
<li><code>int save(const RecordSet&amp; rs, const char* filename)</code>: 4 punti<ul>
<li>salva i records sul file di testo, escludendo i record cancellati</li>
<li>ritorna <code>-1</code> in caso di errore</li>
</ul>
</li>
</ul>
<h2>Regole e Test</h2>
<p>Il programma deve essere scritto nel file <code>esame01.cpp</code>. Potete madoficare il
<code>main()</code> di quel file e usarlo come volete per testare le funzioni che
implementate. Il programma compila e viene lanciato con il comando:</p>
<div class="codehilite"><pre><span></span><code>g++<span class="w"> </span>esame01.cpp<span class="w"> </span>-o<span class="w"> </span>esame01<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>./esame01
</code></pre></div>

<p>Il programma viene testato automaticamente con il comando:</p>
<div class="codehilite"><pre><span></span><code>g++<span class="w"> </span>test01.cpp<span class="w"> </span>-o<span class="w"> </span>test01<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>./test01
</code></pre></div>

<p>Il programma di test collauda le funzioni che avete implementato e assegna un
voto a seconda di quanti test passano. Il voto è la somma dei punteggi elencati
sopra e dipende solo dalla correttza con cui si passano i test. Si può
consegnare solo se il tester ritorna almeno 18. Il voto massimo è 33 che
corrisponde a 30 e lode.</p>
<p>Il test deve compilare e deve completare la sua esecuzione. In ogni altra
evenienza il voto è 0.</p>
  </body>
</html>
